/**
 * Copyright (c) 2012 Yahoo! Inc. All rights reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License. See accompanying LICENSE file.
 */

package shark.bytecode

import java.util.concurrent.{Future, FutureTask, Callable, ConcurrentHashMap => JConcurrentMap}
import org.apache.hadoop.hive.ql.exec.ExprNodeEvaluator
import scala.collection._
import scala.collection.JavaConversions._
import scala.reflect.Manifest._

/**
 * This class generates bytecode to efficiently execute
 * an array of Hive expression node evaluators on each row of input.
 * @author harshars
 */
sealed class Evaluator(val evals: Array[ExprNodeEvaluator], 
    delegate: IEvaluatorDelegate) extends IEvaluator {

  def this(evals: Array[ExprNodeEvaluator]) = {
    this(evals, Evaluator.getDelegate(evals))
  }

  final def evaluate(row: AnyRef): Array[AnyRef] = {
    if(evals.isEmpty) Array[AnyRef]() else {
      delegate.evaluate(evals, row)
    }
  }
}


object Evaluator {

  val map:mutable.ConcurrentMap[Int, Future[IEvaluatorDelegate]] =
    new JConcurrentMap[Int, Future[IEvaluatorDelegate]]()

  val loader = new BytecodeLoader

  def getDelegate(evals: Array[ExprNodeEvaluator]): IEvaluatorDelegate = {

    val suggestedComputation = new FutureTask[IEvaluatorDelegate](
      new Callable[IEvaluatorDelegate] {

        override def call(): IEvaluatorDelegate = {
          val tuple = generateBytecode(evals)
          val klass = loader.loadBytecode(tuple._1, tuple._2)
          klass.newInstance.asInstanceOf[IEvaluatorDelegate]
        }
      })
    val actualComputation = map.putIfAbsent(evals.length, suggestedComputation) match {
      case Some(future) => future
      case None => suggestedComputation.run ; suggestedComputation
    }
    actualComputation.get
  }

   /**
   * Generates efficient bytecode to execute the following:
   * Object[] results = ExprNodeEvaluator[].map(_.evaluate(row)).
   * 1. creates a class that has a single method with signature:
   *    public Object[] evaluate(ExprNodeEvaluator[] evals, Object row)
   * 2. The body of the method unrolls the loop :
   *    for(i<- evals.length) yield(evals(i).evaluate(row)
   * 3. The generated bytecode is named with a classname that depends only on the
   *    size of the array (since the bytecode is the same for a given size, we
   *    can reuse bytecode this way).
   *
   */
  private def generateBytecode(evals: Array[ExprNodeEvaluator]): Tuple2[String, Array[Byte]] = {
    val className = "shark.bytecode.Evaluator" + evals.length
    val newClass = new Bytecode(className, Array[String](classOf[IEvaluatorDelegate].getName))
    val exprNodeEvaluatorClassName = classOf[ExprNodeEvaluator].getName
    val parameters = Array[Manifest[_]](Bytecode.arrayManifest[ExprNodeEvaluator], Object)
    val ret = Bytecode.arrayManifest[AnyRef]

    def seq(index: Int): Seq[MethodInsn] = List(
      ALOAD(3),
      LDC(index),
      ALOAD(1),
      LDC(index),
      AALOAD,
      ALOAD(2),
      DISPATCH(INVOKEVIRTUAL, exprNodeEvaluatorClassName,"evaluate", Array(Object), Object),
      AASTORE
    )

    val numberOfParams = evals.length
    val newSeq = Range(0,numberOfParams).foldLeft(List[MethodInsn]())((s, index) => s ++ seq(index))

    val methodInsn =  List(
      ALOAD(1),
      ARRAYLENGTH,
      ANEWARRAY(Object),
      ASTORE(3)
    )++
    newSeq ++
    List(
      ALOAD(3),
      ARETURN,
      MAX(4,4)
    )
    newClass.addMethod("evaluate", parameters, ret, Array(PUBLIC, FINAL))(methodInsn :_*)
    val bytes = newClass.collect
    (className, bytes)
  }
}